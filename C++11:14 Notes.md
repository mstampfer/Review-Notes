* "What are the differences between rvalues and lvalues?
	* rvalues indicate objects eligible for move operations while lvalues generally don&rsquo;t.
	* rvalues are temporary objects, while lvalues correspond to objects you can refer to, either by name or by following a pointer or lvalue references
	* Copies of rvalues are move constructed, while copies of lvalues are copy constructed
* "What is perfect forwarding?
	* parameters inside functions are lvalues, but the arguments which are passed into the function may be rvalues or lvalues.
	* Perfect Forwarding is when an argument passed to a function is passed to a second function such that the original argument&rsquo;s rvalueness or lvalueness is preserved.
"What's special about universal references using type deduction?","&nbsp;Type deduction distinguishes between lvalue arguments and rvalue arguments.That never happens for non-universal references.",1,1
"During template type deduction what happens to arguments that are references?&nbsp;","reference arguments are treated as non-references, i.e., their reference-ness is ignored.",1,1
"What happens to rvalue and lvalue arguments when deducing types for universal reference parameters?&nbsp;","&nbsp;Universal references parameters correspond to rvalue references if they&rsquo;re initialized with rvalues. They correspond to lvalue references if they&rsquo;re initialized with lvalues.",1,1
"What happens to const and/or volatile arguments when deducing types for by-value parameters","const and volatile arguments are treated as non-const and non-volatile.&nbsp;",1,1
"What happens to&nbsp;array or function names&nbsp;during template type deduction?","arguments that are array or function names decay to pointers, unless they&rsquo;re used to initialize references.",1,1
"What is the deduced type when the initializer for an auto-declared variable is enclosed in braces?&nbsp;","The deduced type is a std::initializer_list.",1,1
"What is the difference between auto and template type deduction for braced initializers?&nbsp;","auto assumes that a braced initializer represents a std::initializer_list, but template type deduction fails to compile for braced initializers.",1,1
"what form of type deduction applies in a function return type or a lambda parameter?&nbsp;","auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.",1,1
"What type is returned by decltype for lvalue expressions of type T other than names?&nbsp;","For lvalue expressions of type T other than names, decltype always reports a type of T&amp;.",1,1
"what is the difference between std::function template and function pointers?&nbsp;","Whereas function pointers can point only to functions, std::function objects can refer to any callable object.",1,1
"What is the advantage of using auto declared objects over std::function template?","std::function object typically uses more memory than the auto-declared object.",1,1
"What are the advantage of using auto?","&nbsp;explicitly specifying types can lead to implicit conversions that you neither want nor expect. You need not worry about mismatches between the type of variable you&rsquo;re declaring and the type of the expression used to initialize it.auto variables must be initializedThey are immune to type mismatches that can lead to portability or efficiency problems.&nbsp;They can ease the process of refactoring.They require less typing than variables with explicitly specified types.&nbsp;",1,1
"What is the problem with std::vector&lt;bool&gt;?","&nbsp;because std::vector&lt;bool&gt; is specified to represent its bools in packed form, one bit per bool, there is a problem for std::vector&lt;bool&gt;&rsquo;s operator[], because operator[] for std::vector&lt;T&gt; is supposed to return a T&amp;, but C++ forbids references to bits.This is why std::vector&lt;bool&gt;::reference exists.",1,1
"What is the explicitly typed initializer idiom?&nbsp;","the explicitly typed initializer idiom is declaring a variable with auto, but casting the initialization expression to the type you want auto to deduce.",1,1
"What is C++'s "most vexing parse"?","the "most vexing parse" is when a default-constructed object is wanted, but inadvertently the result is declaring a function instead.",1,1
"What are the advantages of using braced initialization?","&nbsp;Braced initialization prevents narrowing conversions&nbsp;it&rsquo;s immune to C++&rsquo;s most vexing parse.&nbsp;",1,1
"What are the disadvantages of braced initializers for constructor overload resolution.","During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other constructors offer seemingly better matches.",1,1
"What is the 2 advantages of using nullptr?","nullptr&rsquo;s doesn&rsquo;t have an integral type thus avoids overload resolution surprises.template type deduction deduces the &ldquo;wrong&rdquo; types for 0 and NULL&nbsp;",1,1
"What are the advatage of using alias templates?","alias declarations may be templatized (in which case they&rsquo;re called alias templates), while typedefs cannot.Alias templates avoid the &ldquo;::type&rdquo; suffix&nbsp;and, in templates, the &ldquo;typename&rdquo; prefixC++14 offers alias templates for all the C++11 type traits transformations.",1,1
"What are the C++14 equivalents to the C++11 constructs:// const T &rarr; Tstd::remove_const&lt;T&gt;::type// T&amp;/T&amp;&amp; &rarr; Tstd::remove_reference&lt;T&gt;::type// T &rarr; T&amp;std::add_lvalue_reference&lt;T&gt;::type","// const T &rarr; Tstd::remove_const&lt;T&gt;::type&nbsp;&nbsp;std::remove_const_t&lt;T&gt;// T&amp;/T&amp;&amp; &rarr; Tstd::remove_reference&lt;T&gt;::type std::remove_reference_t&lt;T&gt;// T &rarr; T&amp;std::add_lvalue_reference&lt;T&gt;::type std::add_lvalue_reference_t&lt;T&gt;// C++11: T&amp;/T&amp;&amp; &rarr; T// C++14 equivalent// C++14 equivalent",1,1
"What are the advantages of using scoped desclarations?","&nbsp;reduction in namespace pollution: unscoped enumerator names leak into the scope containing their enum definitionstrongly typed: Enumerators for unsco‐ ped enums implicitly convert to integral typesBoth scoped and unscoped enums support specification of the underlying type.Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.&nbsp;",1,1
"What are the advantages of using scoped desclarations?","&nbsp;reduction in namespace pollution: unscoped enumerator names leak into the scope containing their enum definitionstrongly typed: Enumerators for unsco‐ ped enums implicitly convert to integral typesBoth scoped and unscoped enums support specification of the underlying type.Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.&nbsp;",1,1
"What's special about universal references using type deduction?","&nbsp;Type deduction distinguishes between lvalue arguments and rvalue arguments.That never happens for non-universal references.",1,1
"During template type deduction what happens to arguments that are references?&nbsp;","reference arguments are treated as non-references, i.e., their reference-ness is ignored.",1,1
"What happens to rvalue and lvalue arguments when deducing types for universal reference parameters?&nbsp;","&nbsp;Universal references parameters correspond to rvalue references if they&rsquo;re initialized with rvalues. They correspond to lvalue references if they&rsquo;re initialized with lvalues.",1,1
"What happens to const and/or volatile arguments when deducing types for by-value parameters","const and volatile arguments are treated as non-const and non-volatile.&nbsp;",1,1
"What happens to&nbsp;array or function names&nbsp;during template type deduction?","arguments that are array or function names decay to pointers, unless they&rsquo;re used to initialize references.",1,1
"What is the deduced type when the initializer for an auto-declared variable is enclosed in braces?&nbsp;","The deduced type is a std::initializer_list.",1,1
"What is the difference between auto and template type deduction for braced initializers?&nbsp;","auto assumes that a braced initializer represents a std::initializer_list, but template type deduction fails to compile for braced initializers.",1,1
"what form of type deduction applies in a function return type or a lambda parameter?&nbsp;","auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.",1,1
"What type is returned by decltype for lvalue expressions of type T other than names?&nbsp;","For lvalue expressions of type T other than names, decltype always reports a type of T&amp;.",1,1
"what is the difference between std::function template and function pointers?&nbsp;","Whereas function pointers can point only to functions, std::function objects can refer to any callable object.",1,1
"What is the advantage of using auto declared objects over std::function template?","std::function object typically uses more memory than the auto-declared object.",1,1
"What are the advantage of using auto?","&nbsp;explicitly specifying types can lead to implicit conversions that you neither want nor expect. You need not worry about mismatches between the type of variable you&rsquo;re declaring and the type of the expression used to initialize it.auto variables must be initializedThey are immune to type mismatches that can lead to portability or efficiency problems.&nbsp;They can ease the process of refactoring.They require less typing than variables with explicitly specified types.&nbsp;",1,1
"What is the problem with std::vector&lt;bool&gt;?","&nbsp;because std::vector&lt;bool&gt; is specified to represent its bools in packed form, one bit per bool, there is a problem for std::vector&lt;bool&gt;&rsquo;s operator[], because operator[] for std::vector&lt;T&gt; is supposed to return a T&amp;, but C++ forbids references to bits.This is why std::vector&lt;bool&gt;::reference exists.",1,1
"What is the explicitly typed initializer idiom?&nbsp;","the explicitly typed initializer idiom is declaring a variable with auto, but casting the initialization expression to the type you want auto to deduce.",1,1
"What is C++'s "most vexing parse"?","the "most vexing parse" is when a default-constructed object is wanted, but inadvertently the result is declaring a function instead.",1,1
"What are the advantages of using braced initialization?","&nbsp;Braced initialization prevents narrowing conversions&nbsp;it&rsquo;s immune to C++&rsquo;s most vexing parse.&nbsp;",1,1
"What are the disadvantages of braced initializers for constructor overload resolution.","During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other constructors offer seemingly better matches.",1,1
"What is the 2 advantages of using nullptr?","nullptr&rsquo;s doesn&rsquo;t have an integral type thus avoids overload resolution surprises.template type deduction deduces the &ldquo;wrong&rdquo; types for 0 and NULL&nbsp;",1,1
"What are the advatage of using alias templates?","alias declarations may be templatized (in which case they&rsquo;re called alias templates), while typedefs cannot.Alias templates avoid the &ldquo;::type&rdquo; suffix&nbsp;and, in templates, the &ldquo;typename&rdquo; prefixC++14 offers alias templates for all the C++11 type traits transformations.",1,1
"What are the C++14 equivalents to the C++11 constructs:// const T &rarr; Tstd::remove_const&lt;T&gt;::type// T&amp;/T&amp;&amp; &rarr; Tstd::remove_reference&lt;T&gt;::type// T &rarr; T&amp;std::add_lvalue_reference&lt;T&gt;::type","// const T &rarr; Tstd::remove_const&lt;T&gt;::type&nbsp;&nbsp;std::remove_const_t&lt;T&gt;// T&amp;/T&amp;&amp; &rarr; Tstd::remove_reference&lt;T&gt;::type std::remove_reference_t&lt;T&gt;// T &rarr; T&amp;std::add_lvalue_reference&lt;T&gt;::type std::add_lvalue_reference_t&lt;T&gt;// C++11: T&amp;/T&amp;&amp; &rarr; T// C++14 equivalent// C++14 equivalent",1,1
